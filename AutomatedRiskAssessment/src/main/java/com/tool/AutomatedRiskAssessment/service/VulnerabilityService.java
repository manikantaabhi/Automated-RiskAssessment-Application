package com.tool.AutomatedRiskAssessment.service;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.multipart.MultipartFile;

import com.tool.AutomatedRiskAssessment.dto.Vulnerabilities;
import com.tool.AutomatedRiskAssessment.model.VulnerabilityDetails;
//import com.tool.AutomatedRiskAssessment.model.VulnerabilityDetailsReferences;
//import com.tool.AutomatedRiskAssessment.repo.VulnerabilityDetailsReferencesRepository;
import com.tool.AutomatedRiskAssessment.repo.VulnerabilityDetailsRepository;
import jakarta.transaction.Transactional;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.*;
import java.util.stream.Collectors;

@Service
public class VulnerabilityService {

	private static final String NVD_API_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0";
    
    private final RestTemplate restTemplate = new RestTemplate();
    
	 @Autowired
	 private VulnerabilityDetailsRepository vulnerabilityDetailsRepository;
	 
	 //@Autowired
	 //private VulnerabilityDetailsReferencesRepository vulnerabilityDetailsReferencesRepository;

    // Fetch vulnerabilities based on the provided company, product, version, and type
    public List<Vulnerabilities> fetchVulnerabilities(String company, String product, String version, String type, String keywords) {
        String cpeName = "";
        System.out.println("entering the fetch vulnerabilities method");

        // Check the type and construct the CPE name accordingly
        if ((type.equals("os") || type.equals("app")) && version != null && !version.equals("N/A")) {
            // OS or Software type with non-null, non-"N/A" version
            if (type.equals("os")) {
                cpeName = String.format("cpe:2.3:o:%s:%s:%s:*:*:*:*:*:*:*", company, product, version);
            } else if (type.equals("app")) {
                cpeName = String.format("cpe:2.3:a:%s:%s:%s:*:*:*:*:*:*:*", company, product, version);
            }
        } else if (type.equals("hardware")) {
            // Hardware type (version can be null)
            if (version != null && !version.equals("N/A")) {
                cpeName = String.format("cpe:2.3:h:%s:%s:%s:*:*:*:*:*:*:*", company, product, version);
            } else {
                cpeName = String.format("cpe:2.3:h:%s:%s:*:*:*:*:*:*:*", company, product);
            }
        } 
        /*else {
            // If version is "N/A" or null for OS/software, or any other invalid case
            if (type.equals("os")) {
                cpeName = String.format("cpe:2.3:o:%s:%s:*:*:*:*:*:*:*", company, product);
            } else if (type.equals("app")) {
                cpeName = String.format("cpe:2.3:a:%s:%s:*:*:*:*:*:*:*", company, product);
            } else if (type.equals("hardware")) {
                cpeName = String.format("cpe:2.3:h:%s:%s:*:*:*:*:*:*:*", company, product);
            }
        }*/
        // Construct the URL using CPE name and optional keyword search
        //if (keywords == null) keywords = "";
        if (keywords == null) keywords = "";
        System.out.println("cpe name is created:" + cpeName);
        String url = NVD_API_URL.concat("?cpeName=").concat(cpeName).concat("&keywordSearch=").concat(keywords);
        
        System.out.println("Fetching vulnerabilities from: " + url);

        Map<String, Object> response = restTemplate.getForObject(url, Map.class);
        System.out.println("hitting HTTP GET request");
        if (response == null || !response.containsKey("vulnerabilities")) {
            return new ArrayList<>();
        }

        List<Map<String, Object>> cveItems = (List<Map<String, Object>>) response.get("vulnerabilities");
        List<Vulnerabilities> vulnerabilities = new ArrayList<>();
        LocalDate today = LocalDate.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSS");

        // Process the CVE items
        for (Map<String, Object> cveItem : cveItems) {
            Map<String, Object> cveData = (Map<String, Object>) cveItem.get("cve");

            // Extract lastModified date
            String lastModifiedStr = (String) cveData.get("lastModified");
            LocalDate lastModified = null;
            try {
                lastModified = LocalDate.parse(lastModifiedStr, formatter);
                if (lastModified.isBefore(today.minusDays(60))) {
                    continue;  // Skip vulnerabilities older than 60 days
                }
            } catch (DateTimeParseException e) {
                System.out.println("Invalid date format for CVE: " + cveData.get("id"));
                continue;
            }

            // Extract other CVE details (ID, description, severity, etc.)
            String cveId = (String) cveData.get("id");
            List<Map<String, Object>> descriptions = (List<Map<String, Object>>) cveData.get("descriptions");
            String description = descriptions != null && !descriptions.isEmpty()
                    ? (String) descriptions.get(0).get("value")
                    : "No description available";

            double baseScore = 0.0;
            String severity = "UNKNOWN";
            if (cveData.containsKey("metrics")) {
                Map<String, Object> metrics = (Map<String, Object>) cveData.get("metrics");
                if (metrics.containsKey("cvssMetricV31")) {
                    Map<String, Object> cvssV3 = (Map<String, Object>) ((List<Map<String, Object>>) metrics.get("cvssMetricV31")).get(0).get("cvssData");
                    baseScore = (double) cvssV3.get("baseScore");
                    severity = (String) cvssV3.get("baseSeverity");
                }
            }

            String references = "";
            if (cveData.containsKey("references")) {
                List<Map<String, Object>> referenceData = (List<Map<String, Object>>) cveData.get("references");
                references = referenceData.stream()
                        .map(ref -> (String) ref.get("url"))
                        .collect(Collectors.joining(", ")); // Join into a single string
            }

            vulnerabilities.add(new Vulnerabilities(company, product, version, cveId, description, baseScore, severity, lastModified, references, type));
        }

        return vulnerabilities;
    }

    // Parse the CSV file and fetch vulnerabilities
    public List<String[]> parseCsvFile(MultipartFile file) {
        List<String[]> parsedData = new ArrayList<>();
        
        if (file != null && !file.isEmpty()) {
            try (BufferedReader br = new BufferedReader(new InputStreamReader(file.getInputStream()))) {
                String line;
                boolean isFirstRow = true; // Flag to track header row
                
                while ((line = br.readLine()) != null) {
                    if (isFirstRow) { 
                        isFirstRow = false; // Skip the first row (header)
                        continue;
                    }
                    parsedData.add(line.split(",")); // Assuming CSV format
                }
            } catch (IOException e) {
                throw new RuntimeException("Error reading file content", e);
            }
        }

        List<Map<String, String>> distinctElements = getDistinctElements(parsedData);

        // Printing distinct elements for reference
        System.out.println("Distinct Elements:");
        distinctElements.forEach(System.out::println);

        List<Vulnerabilities> allVulnerabilities = new ArrayList<>();
        for (Map<String, String> element : distinctElements) {
            String company = element.get("make");
            String product = element.get("product");
            String version = element.get("version");
            String type = element.get("type");

            // Fetch vulnerabilities for each distinct element
            List<Vulnerabilities> vulnerabilities = fetchVulnerabilities(company, product, version, type, null);
            saveVulnerabilities(vulnerabilities);  // Save the vulnerabilities to the database
            allVulnerabilities.addAll(vulnerabilities);
        }

        return parsedData;
    }


    // Get distinct elements based on input parsed data
    private List<Map<String, String>> getDistinctElements(List<String[]> parsedData) {
        Set<Map<String, String>> distinctSet = new HashSet<>();

        for (String[] row : parsedData) {
            if (row.length < 4) {  // Skip invalid rows early
                System.err.println("Skipping invalid row: " + Arrays.toString(row));
                continue;
            }

            Map<String, String> element = new HashMap<>();
            element.put("make", row[0].trim());
            element.put("product", row[1].trim());
            element.put("version", row[2].trim());
            element.put("type", row[3].trim());

            // Add to the set to ensure uniqueness
            distinctSet.add(element);
        }

        return new ArrayList<>(distinctSet);
    }

    @Transactional
    public void saveVulnerabilities(List<Vulnerabilities> vulnerabilities) {
        int count = 0;
        List<Vulnerabilities> alreadySaved = new ArrayList<>();

        for (Vulnerabilities vulnerability : vulnerabilities) {
            if (vulnerabilityDetailsRepository.existsByCveId(vulnerability.getCveId())) {
                alreadySaved.add(vulnerability);
                System.out.println("Skipping duplicate CVE: " + vulnerability.getCveId());
                continue;
            }

            VulnerabilityDetails details = new VulnerabilityDetails();
            details.setCveId(vulnerability.getCveId());
            details.setDescription(vulnerability.getDescription());
            details.setBaseScore(vulnerability.getBaseScore());
            details.setSeverity(vulnerability.getSeverity());
            details.setLastModified(vulnerability.getLastModified());
            details.setCompany(vulnerability.getCompany());
            details.setProduct(vulnerability.getProduct());
            details.setVersion(vulnerability.getVersion());
            details.setType(vulnerability.getType());
            details.setReferences(vulnerability.getReferences());

            try {
                vulnerabilityDetailsRepository.save(details);
                count++;
                System.out.println("Saved CVE: " + vulnerability.getCveId());
            } catch (Exception e) {
                alreadySaved.add(vulnerability);
                System.err.println("Error saving CVE: " + vulnerability.getCveId());
                System.err.println("Exception: " + e.getMessage());
            }
        }

        System.out.println("Total saved: " + count);
        System.out.println("Duplicates: " + alreadySaved.size());
    }

}
