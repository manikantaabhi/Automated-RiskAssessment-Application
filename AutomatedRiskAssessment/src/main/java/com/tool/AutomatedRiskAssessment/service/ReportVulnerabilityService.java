package com.tool.AutomatedRiskAssessment.service;
// ‚úÖ [1] NEW IMPORTS
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;

// ... your existing imports
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.multipart.MultipartFile;

import com.tool.AutomatedRiskAssessment.dto.VulnerabilitiesReportDTO;
import com.tool.AutomatedRiskAssessment.model.VulnerabilityReport;
//import com.tool.AutomatedRiskAssessment.model.VulnerabilityDetailsReferences;
//import com.tool.AutomatedRiskAssessment.repo.VulnerabilityDetailsReferencesRepository;
import com.tool.AutomatedRiskAssessment.repo.VulnerabilityDetailsReportRepository;
import jakarta.transaction.Transactional;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.time.LocalDate;
import java.time.Period;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.*;
import java.util.stream.Collectors;

@Service
public class ReportVulnerabilityService {

	private static final String NVD_API_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0";

	private final RestTemplate restTemplate = new RestTemplate();

	@Autowired
	private VulnerabilityDetailsReportRepository vulnerabilityDetailsReportRepository;

	// ‚úÖ [2] NEW METHOD: filter + count + handle file/manual logic
	public Map<String, Object> processWithDateFilter(String make, String product, String version, String type,
			String fromDateStr, String toDateStr, MultipartFile file) {

		LocalDate fromDate = LocalDate.parse(fromDateStr); // ‚úÖ new
		LocalDate toDate = LocalDate.parse(toDateStr); // ‚úÖ new

		Map<String, Integer> countMap = new HashMap<>(); // ‚úÖ new
		List<VulnerabilitiesReportDTO> allVulnerabilities = new ArrayList<>(); // ‚úÖ new

		if (file != null && !file.isEmpty()) {
			List<String[]> parsedData = parseCsvFile(file);
			List<Map<String, String>> distinctElements = getDistinctElements(parsedData);

			for (Map<String, String> element : distinctElements) {
				String company = element.get("make");
				String prod = element.get("product");
				String ver = element.get("version");
				String ty = element.get("type");

				List<VulnerabilitiesReportDTO> result = fetchVulnerabilitiesWithDateFilter(company, prod, ver, ty, null,
						fromDate, toDate); // ‚úÖ new method call

				String key = company + "-" + prod + "-" + ver; // ‚úÖ
				countMap.put(key, result.size()); // ‚úÖ

				saveVulnerabilities(result); // existing
				allVulnerabilities.addAll(result); // ‚úÖ
			}

		} else if (make != null && product != null && version != null && type != null) {
			List<VulnerabilitiesReportDTO> result = fetchVulnerabilitiesWithDateFilter(make, product, version, type, null,
					fromDate, toDate); // ‚úÖ

			String key = make + "-" + product + "-" + version; // ‚úÖ
			countMap.put(key, result.size()); // ‚úÖ

			saveVulnerabilities(result);
			allVulnerabilities.addAll(result);
		}
		

		Map<String, Object> response = new HashMap<>(); // ‚úÖ
		response.put("vulnerabilities", allVulnerabilities); // ‚úÖ
		response.put("counts", countMap); // ‚úÖ
		
		
		
		// ‚úÖ NEW LOGIC: Dynamic grouping granularity
        long totalMonths = Period.between(fromDate.withDayOfMonth(1), toDate.withDayOfMonth(1)).toTotalMonths();

        String groupingType;
        if (totalMonths <= 12) {
            groupingType = "monthly";
        } else if (totalMonths <= 24) {
            groupingType = "quarterly";
        } else if (totalMonths <= 36) {
            groupingType = "halfyearly";
        } else {
            groupingType = "yearly";
        }

        // ‚úÖ NEW: Format data according to the groupingType
        List<Map<String, Object>> formattedGraphData = new ArrayList<>();

        Map<String, Map<String, Long>> grouped = allVulnerabilities.stream()
            .collect(Collectors.groupingBy(
                v -> v.getCompany() + "|" + v.getProduct() + "|" + v.getVersion() + "|" + v.getType(),
                Collectors.groupingBy(
                    v -> {
                        LocalDate d = v.getLastModified();
                        switch (groupingType) {
                            case "monthly":
                                return d.format(DateTimeFormatter.ofPattern("yyyy-MM"));
                            case "quarterly":
                                int q = (d.getMonthValue() - 1) / 3 + 1;
                                return d.getYear() + "-Q" + q;
                            case "halfyearly":
                                String half = d.getMonthValue() <= 6 ? "H1" : "H2";
                                return d.getYear() + "-" + half;
                            case "yearly":
                            default:
                                return String.valueOf(d.getYear());
                        }
                    },
                    Collectors.counting()
                )
            ));

        for (Map.Entry<String, Map<String, Long>> entry : grouped.entrySet()) {
            String[] parts = entry.getKey().split("\\|");

            Map<String, Object> obj = new HashMap<>();
            obj.put("make", parts[0]);
            obj.put("product", parts[1]);
            obj.put("version", parts[2]);
            obj.put("type", parts[3]);

            List<Map<String, Object>> dataPoints = entry.getValue().entrySet().stream().map(e -> {
                Map<String, Object> dp = new HashMap<>();
                dp.put(groupingType.equals("monthly") ? "month" : "year", e.getKey());
                dp.put("count", e.getValue());
                return dp;
            }).collect(Collectors.toList());

            obj.put("dataPoints", dataPoints);
            formattedGraphData.add(obj);
        }

        response.put("graphData", formattedGraphData); // ‚úÖ new field
        return response;
    }

	// ‚úÖ [3] NEW METHOD: Date-based filtering logic
	public List<VulnerabilitiesReportDTO> fetchVulnerabilitiesWithDateFilter(String company, String product, String version,
			String type, String keywords, LocalDate fromDate, LocalDate toDate) {
		List<VulnerabilitiesReportDTO> original = fetchVulnerabilities(company, product, version, type, keywords);
		return original.stream()
				.filter(v -> !v.getLastModified().isBefore(fromDate) && !v.getLastModified().isAfter(toDate)) // ‚úÖ date
																												// filter
				.collect(Collectors.toList());
	}

	// ---------------------------
	// üîÅ Everything below this is your original code
	// ---------------------------

	public List<VulnerabilitiesReportDTO> fetchVulnerabilities(String company, String product, String version, String type,
			String keywords) {
		// üîÅ Unchanged existing logic
		String cpeName = "";
		System.out.println("entering the fetch vulnerabilities method");

		if ((type.equals("os") || type.equals("app")) && version != null && !version.equals("N/A")) {
			if (type.equals("os")) {
				cpeName = String.format("cpe:2.3:o:%s:%s:%s:*:*:*:*:*:*:*", company, product, version);
			} else if (type.equals("app")) {
				cpeName = String.format("cpe:2.3:a:%s:%s:%s:*:*:*:*:*:*:*", company, product, version);
			}
		} else if (type.equals("hardware")) {
			if (version != null && !version.equals("N/A")) {
				cpeName = String.format("cpe:2.3:h:%s:%s:%s:*:*:*:*:*:*:*", company, product, version);
			} else {
				cpeName = String.format("cpe:2.3:h:%s:%s:*:*:*:*:*:*:*", company, product);
			}
		}

		if (keywords == null)
			keywords = "";
		System.out.println("cpe name is created:" + cpeName);
		String url = NVD_API_URL.concat("?cpeName=").concat(cpeName).concat("&keywordSearch=").concat(keywords);

		System.out.println("Fetching vulnerabilities from: " + url);
		Map<String, Object> response = restTemplate.getForObject(url, Map.class);
		System.out.println("hitting HTTP GET request");

		if (response == null || !response.containsKey("vulnerabilities")) {
			return new ArrayList<>();
		}

		List<Map<String, Object>> cveItems = (List<Map<String, Object>>) response.get("vulnerabilities");
		List<VulnerabilitiesReportDTO> vulnerabilities = new ArrayList<>();
		LocalDate today = LocalDate.now();
		DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSS");

		for (Map<String, Object> cveItem : cveItems) {
			Map<String, Object> cveData = (Map<String, Object>) cveItem.get("cve");

			String lastModifiedStr = (String) cveData.get("lastModified");
			LocalDate lastModified = null;
			try {
				lastModified = LocalDate.parse(lastModifiedStr, formatter);
				if (lastModified.isBefore(today.minusDays(60))) {
					continue;
				}
			} catch (DateTimeParseException e) {
				System.out.println("Invalid date format for CVE: " + cveData.get("id"));
				continue;
			}

			String cveId = (String) cveData.get("id");
			List<Map<String, Object>> descriptions = (List<Map<String, Object>>) cveData.get("descriptions");
			String description = descriptions != null && !descriptions.isEmpty()
					? (String) descriptions.get(0).get("value")
					: "No description available";

			double baseScore = 0.0;
			String severity = "UNKNOWN";
			if (cveData.containsKey("metrics")) {
				Map<String, Object> metrics = (Map<String, Object>) cveData.get("metrics");
				if (metrics.containsKey("cvssMetricV31")) {
					Map<String, Object> cvssV3 = (Map<String, Object>) ((List<Map<String, Object>>) metrics
							.get("cvssMetricV31")).get(0).get("cvssData");
					baseScore = (double) cvssV3.get("baseScore");
					severity = (String) cvssV3.get("baseSeverity");
				}
			}

			String references = "";
			if (cveData.containsKey("references")) {
				List<Map<String, Object>> referenceData = (List<Map<String, Object>>) cveData.get("references");
				references = referenceData.stream().map(ref -> (String) ref.get("url"))
						.collect(Collectors.joining(", "));
			}

			vulnerabilities.add(new VulnerabilitiesReportDTO(company, product, version, cveId, description, baseScore, severity,
					lastModified, references, type));
		}

		return vulnerabilities;
	}

	// üîÅ parseCsvFile(), getDistinctElements(), saveVulnerabilities()
	//existing code
	// Parse the CSV file and fetch vulnerabilities
    public List<String[]> parseCsvFile(MultipartFile file) {
        List<String[]> parsedData = new ArrayList<>();
        
        if (file != null && !file.isEmpty()) {
            try (BufferedReader br = new BufferedReader(new InputStreamReader(file.getInputStream()))) {
                String line;
                boolean isFirstRow = true; // Flag to track header row
                
                while ((line = br.readLine()) != null) {
                    if (isFirstRow) { 
                        isFirstRow = false; // Skip the first row (header)
                        continue;
                    }
                    parsedData.add(line.split(",")); // Assuming CSV format
                }
            } catch (IOException e) {
                throw new RuntimeException("Error reading file content", e);
            }
        }

        List<Map<String, String>> distinctElements = getDistinctElements(parsedData);

        // Printing distinct elements for reference
        System.out.println("Distinct Elements:");
        distinctElements.forEach(System.out::println);

        List<VulnerabilitiesReportDTO> allVulnerabilities = new ArrayList<>();
        for (Map<String, String> element : distinctElements) {
            String company = element.get("make");
            String product = element.get("product");
            String version = element.get("version");
            String type = element.get("type");

            // Fetch vulnerabilities for each distinct element
            List<VulnerabilitiesReportDTO> vulnerabilities = fetchVulnerabilities(company, product, version, type, null);
            saveVulnerabilities(vulnerabilities);  // Save the vulnerabilities to the database
            allVulnerabilities.addAll(vulnerabilities);
        }

        return parsedData;
    }
    

    // Get distinct elements based on input parsed data
    private List<Map<String, String>> getDistinctElements(List<String[]> parsedData) {
        Set<Map<String, String>> distinctSet = new HashSet<>();

        for (String[] row : parsedData) {
            if (row.length < 4) {  // Skip invalid rows early
                System.err.println("Skipping invalid row: " + Arrays.toString(row));
                continue;
            }

            Map<String, String> element = new HashMap<>();
            element.put("make", row[0].trim());
            element.put("product", row[1].trim());
            element.put("version", row[2].trim());
            element.put("type", row[3].trim());

            // Add to the set to ensure uniqueness
            distinctSet.add(element);
        }

        return new ArrayList<>(distinctSet);
    }

    @Transactional
    public void saveVulnerabilities(List<VulnerabilitiesReportDTO> vulnerabilities) {
        int count = 0;
        List<VulnerabilitiesReportDTO> alreadySaved = new ArrayList<>();

        for (VulnerabilitiesReportDTO vulnerability : vulnerabilities) {
            if (vulnerabilityDetailsReportRepository.existsByCveId(vulnerability.getCveId())) {
                alreadySaved.add(vulnerability);
                System.out.println("Skipping duplicate CVE: " + vulnerability.getCveId());
                continue;
            }

            VulnerabilityReport details = new VulnerabilityReport();
            details.setCveId(vulnerability.getCveId());
            details.setDescription(vulnerability.getDescription());
            details.setBaseScore(vulnerability.getBaseScore());
            details.setSeverity(vulnerability.getSeverity());
            details.setLastModified(vulnerability.getLastModified());
            details.setCompany(vulnerability.getCompany());
            details.setProduct(vulnerability.getProduct());
            details.setVersion(vulnerability.getVersion());
            details.setType(vulnerability.getType());
            details.setReferences(vulnerability.getReferences());

            try {
                vulnerabilityDetailsReportRepository.save(details);
                count++;
                System.out.println("Saved CVE: " + vulnerability.getCveId());
            } catch (Exception e) {
                alreadySaved.add(vulnerability);
                System.err.println("Error saving CVE: " + vulnerability.getCveId());
                System.err.println("Exception: " + e.getMessage());
            }
        }

        System.out.println("Total saved: " + count);
        System.out.println("Duplicates: " + alreadySaved.size());
    }

}