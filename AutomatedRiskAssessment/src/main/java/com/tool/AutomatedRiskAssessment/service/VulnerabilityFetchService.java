package com.tool.AutomatedRiskAssessment.service;

import com.tool.AutomatedRiskAssessment.model.Notification;
import com.tool.AutomatedRiskAssessment.model.ScheduledJob;
import com.tool.AutomatedRiskAssessment.model.User;
import com.tool.AutomatedRiskAssessment.model.Vulnerability;
import com.tool.AutomatedRiskAssessment.repo.NotificationRepository;
import com.tool.AutomatedRiskAssessment.repo.ScheduledJobRepository;
import com.tool.AutomatedRiskAssessment.repo.UserRepository;
import com.tool.AutomatedRiskAssessment.repo.VulnerabilityRepository;
import jakarta.mail.MessagingException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class VulnerabilityFetchService {

    @Autowired
    private VulnerabilityRepository vulnerabilityRepository;

    @Autowired
    private ScheduledJobRepository scheduledJobRepository;

    @Autowired
    private NotificationRepository notificationRepository;

    @Autowired
    private EmailService emailService;

    // Autowire the UserRepository to get user email from the Users table
    @Autowired
    private UserRepository userRepository;

    private RestTemplate restTemplate = new RestTemplate();

    // Set to true to test with dummy vulnerability; set to false to call the real API.
    private boolean testingDummy = true;

    /**
     * Fetch vulnerabilities from the API (or dummy data) every 5 minutes.
     * It uses a publication date range from (now - 5 minutes) to now.
     * New vulnerabilities (i.e. those not already in the DB) are saved.
     */
    @Scheduled(fixedRate = 300000)
    public void fetchNewVulnerabilitiesFromApi() {
        // Calculate the time window: from 5 minutes ago until now
        LocalDateTime now = LocalDateTime.now();
        LocalDateTime startTime = now.minusMinutes(5);

        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'");
        String pubStartDate = startTime.format(formatter);
        String pubEndDate = now.format(formatter);

        String baseUrl = "https://services.nvd.nist.gov/rest/json/cves/2.0";
        String query = "?resultsPerPage=20&startIndex=0" +
                "&pubStartDate=" + URLEncoder.encode(pubStartDate, StandardCharsets.UTF_8) +
                "&pubEndDate=" + URLEncoder.encode(pubEndDate, StandardCharsets.UTF_8);
        String url = baseUrl + query;

        try {
            System.out.println("Fetching vulnerabilities from: " + url);
            VulnerabilityResponse response;
            if (testingDummy) {
                // Create a dummy vulnerability for testing within the 5-min window
                Vulnerability dummyVuln = new Vulnerability();
                dummyVuln.setCveId("CVE-TEST-0003");
                dummyVuln.setDescription("Dummy Description vulnerability for testing.");
                // Set publishedDate to (now - 1 minute) so it falls within the window
                LocalDateTime dummyPublishedDate = now.minusMinutes(1);
                dummyVuln.setPublishedDate(dummyPublishedDate);
                dummyVuln.setBaseScore(0.0);
                // Set fields used for matching scheduled job criteria
                dummyVuln.setVendor("Adobe");
                dummyVuln.setProductName("Acrobat");
                dummyVuln.setVersion("10");
                dummyVuln.setKeywords("test");

                VulnerabilityResponse dummyResponse = new VulnerabilityResponse();
                Result dummyResult = new Result();
                dummyResult.setCveItems(List.of(dummyVuln));
                dummyResponse.setResult(dummyResult);
                response = dummyResponse;
            } else {
                response = restTemplate.getForObject(url, VulnerabilityResponse.class);
            }
            if (response != null && response.getResult() != null) {
                List<Vulnerability> vulnerabilities = response.getResult().getCveItems();
                if (vulnerabilities != null) {
                    // Save only new vulnerabilities (by checking the CVE id)
                    List<Vulnerability> newVulns = vulnerabilities.stream()
                            .filter(vuln -> !vulnerabilityRepository.existsByCveId(vuln.getCveId()))
                            .collect(Collectors.toList());
                    newVulns.forEach(vuln -> {
                        vulnerabilityRepository.save(vuln);
                    });
                    System.out.println("Fetched " + vulnerabilities.size() +
                            " vulnerabilities, saved " + newVulns.size() + " new ones.");
                } else {
                    System.out.println("No vulnerabilities found in API response.");
                }
            } else {
                System.out.println("Empty response received from API.");
            }
        } catch (Exception e) {
            System.err.println("Error fetching vulnerabilities: " + e.getMessage());
        }
    }

    /**
     * Process scheduled jobs every 5 minutes (with a slight initial delay so that API fetch has run).
     * For each active job, check the vulnerabilities table for vulnerabilities published within
     * the last 5 minutes that match the job criteria (vendor, product name, version, and keywords) and notify the user.
     */
    @Scheduled(fixedRate = 300000, initialDelay = 60000)
    public void processScheduledJobs() {
        // Calculate the time window: vulnerabilities added in the last 5 minutes
        LocalDateTime now = LocalDateTime.now();
        LocalDateTime startTime = now.minusMinutes(5);

        // Assumes vulnerabilityRepository has a method to find by publishedDate range.
        List<Vulnerability> recentVulns = vulnerabilityRepository.findByPublishedDateBetween(startTime, now);
        if (recentVulns == null || recentVulns.isEmpty()) {
            System.out.println("No new vulnerabilities found in the last 5 minutes.");
            return;
        }
        System.out.println("Processing scheduled jobs for vulnerabilities published between " + startTime + " and " + now);

        // Retrieve all active scheduled jobs (status == SCHEDULED)
        List<ScheduledJob> activeJobs = scheduledJobRepository.findAll()
                .stream()
                .filter(job -> job.getStatus() == ScheduledJob.JobStatus.SCHEDULED)
                .collect(Collectors.toList());

        for (ScheduledJob job : activeJobs) {
            // Filter vulnerabilities that match the job's criteria
            List<Vulnerability> matchingVulns = recentVulns.stream()
                    .filter(vuln -> matchesJobCriteria(vuln, job))
                    .collect(Collectors.toList());

            matchingVulns.forEach(vuln -> {
                // Create a notification for each matching vulnerability
                Notification notification = new Notification();
                notification.setUserId(job.getUserId());
                notification.setJobId(job.getId());
                notification.setMessage("New vulnerability " + vuln.getCveId() + " detected for job '" + job.getJobName() + "'.");
                notification.setReadFlag(false);
                notificationRepository.save(notification);

                // Retrieve the user's email from the Users table using userId
                String userEmail = "user@example.com"; // default fallback
                Optional<User> userOpt = userRepository.findById(job.getUserId());
                if (userOpt.isPresent() && userOpt.get().getEmail() != null && !userOpt.get().getEmail().isEmpty()) {
                    userEmail = userOpt.get().getEmail();
                    System.out.println("User email found: " + userEmail);
                } else {
                    System.out.println("No email found for user id " + job.getUserId() + ", using default.");
                }

                System.out.println("Sending email to: " + userEmail + " for job " + job.getId());
                String subject = "New Vulnerability Detected for Job: " + job.getJobName();
                String body = "A new vulnerability (" + vuln.getCveId() + ") has been detected for your scheduled job.\n\nDescription: " + vuln.getDescription();
                try {
                    emailService.sendEmail(userEmail, subject, body);
                } catch (MessagingException me) {
                    System.err.println("Error sending email for job " + job.getId() + ": " + me.getMessage());
                }
            });

            System.out.println("Job " + job.getId() + ": Processed " + matchingVulns.size() + " new vulnerabilities.");
        }
    }

    /**
     * Helper method to check whether a vulnerability matches a scheduled job's criteria.
     * Matches are based on vendor, product name, version and, if provided, keywords.
     */
    private boolean matchesJobCriteria(Vulnerability vuln, ScheduledJob job) {
        // Check vendor match
        if (job.getVendor() != null && !job.getVendor().isEmpty()) {
            if (vuln.getVendor() == null || !vuln.getVendor().equalsIgnoreCase(job.getVendor())) {
                return false;
            }
        }
        // Check product name match
        if (job.getProductName() != null && !job.getProductName().isEmpty()) {
            if (vuln.getProductName() == null || !vuln.getProductName().equalsIgnoreCase(job.getProductName())) {
                return false;
            }
        }
        // Check version match
        if (job.getVersion() != null && !job.getVersion().isEmpty()) {
            if (vuln.getVersion() == null || !vuln.getVersion().equalsIgnoreCase(job.getVersion())) {
                return false;
            }
        }
        // Check keywords match (if provided, vulnerability's keywords should contain the job's keywords)
        if (job.getKeywords() != null && !job.getKeywords().isEmpty()) {
            if (vuln.getKeywords() == null || !vuln.getKeywords().toLowerCase().contains(job.getKeywords().toLowerCase())) {
                return false;
            }
        }
        return true;
    }

    /**
     * Wrapper classes for mapping the NVD API JSON response.
     * Adjust these classes to match the exact response structure from the NVD API v2.0.
     */
    public static class VulnerabilityResponse {
        private Result result;

        public Result getResult() {
            return result;
        }

        public void setResult(Result result) {
            this.result = result;
        }
    }

    public static class Result {
        // Assumes vulnerabilities are returned in a field named "cveItems".
        private List<Vulnerability> cveItems;

        public List<Vulnerability> getCveItems() {
            return cveItems;
        }

        public void setCveItems(List<Vulnerability> cveItems) {
            this.cveItems = cveItems;
        }
    }
}