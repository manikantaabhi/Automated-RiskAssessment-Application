package com.tool.AutomatedRiskAssessment.service;

import com.tool.AutomatedRiskAssessment.model.Notification;
import com.tool.AutomatedRiskAssessment.model.ScheduledJob;
import com.tool.AutomatedRiskAssessment.model.User;
import com.tool.AutomatedRiskAssessment.model.Vulnerability;
import com.tool.AutomatedRiskAssessment.repo.NotificationRepository;
import com.tool.AutomatedRiskAssessment.repo.ScheduledJobRepository;
import com.tool.AutomatedRiskAssessment.repo.UserRepository;
import com.tool.AutomatedRiskAssessment.repo.VulnerabilityRepository;
import jakarta.mail.MessagingException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class VulnerabilityFetchService {

    @Autowired
    private VulnerabilityRepository vulnerabilityRepository;

    @Autowired
    private ScheduledJobRepository scheduledJobRepository;

    @Autowired
    private NotificationRepository notificationRepository;

    @Autowired
    private EmailService emailService;

    // New: Autowire the UserRepository to get user email from the users table
    @Autowired
    private UserRepository userRepository;

    private RestTemplate restTemplate = new RestTemplate();

    // Set to true to test with a dummy vulnerability; set to false and call the real API.
    private boolean testingDummy = true;

    /**
     * Scheduled to run every 5 minutes.
     * For each active scheduled job (status SCHEDULED), fetch vulnerabilities from the NVD API
     * using that jobâ€™s details, store any new vulnerabilities in the database, create notifications,
     * and send an email notification.
     */
    @Scheduled(fixedRate = 300000)
    public void fetchAndStoreVulnerabilitiesForActiveJobs() {
        // Retrieve active jobs (status == SCHEDULED)
        List<ScheduledJob> activeJobs = scheduledJobRepository.findAll()
                .stream()
                .filter(job -> job.getStatus() == ScheduledJob.JobStatus.SCHEDULED)
                .collect(Collectors.toList());

        for (ScheduledJob job : activeJobs) {
            String url = buildNvdApiUrlForJob(job);
            try {
                System.out.println("Fetching vulnerabilities for job " + job.getId() + " from: " + url);
                VulnerabilityResponse response;
                if (testingDummy) {
                    // Create a dummy vulnerability for testing
                    Vulnerability dummyVuln = new Vulnerability();
                    dummyVuln.setCveId("CVE-TEST-0001");
                    dummyVuln.setDescription("Dummy vulnerability for testing.");
                    DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'");
                    LocalDateTime publishedDate = LocalDateTime.parse("2025-03-26T03:00:00.000Z", formatter);
                    dummyVuln.setPublishedDate(publishedDate);
                    dummyVuln.setBaseScore(0.0);
                    System.out.println("Dummy vulnerability baseScore: " + dummyVuln.getBaseScore());

                    VulnerabilityResponse dummyResponse = new VulnerabilityResponse();
                    Result dummyResult = new Result();
                    dummyResult.setCveItems(List.of(dummyVuln));
                    dummyResponse.setResult(dummyResult);
                    response = dummyResponse;
                } else {
                    response = restTemplate.getForObject(url, VulnerabilityResponse.class);
                }
                if (response != null && response.getResult() != null) {
                    List<Vulnerability> vulnerabilities = response.getResult().getCveItems();
                    if (vulnerabilities != null) {
                        // Filter vulnerabilities that are not already in the database by checking cveId.
                        List<Vulnerability> newVulns = vulnerabilities.stream()
                                .filter(vuln -> !vulnerabilityRepository.existsByCveId(vuln.getCveId()))
                                .collect(Collectors.toList());
                        newVulns.forEach(vuln -> {
                            vulnerabilityRepository.save(vuln);
                            // Create a notification for each new vulnerability
                            Notification notification = new Notification();
                            notification.setUserId(job.getUserId());
                            notification.setJobId(job.getId());
                            notification.setMessage("New vulnerability " + vuln.getCveId() + " detected for job '" + job.getJobName() + "'.");
                            notification.setReadFlag(false);
                            notificationRepository.save(notification);

                            // Retrieve the user's email from the Users table using userId
                            String userEmail = "user@example.com"; // default
                            Optional<User> userOpt = userRepository.findById(job.getUserId());
                            if (userOpt.isPresent() && userOpt.get().getEmail() != null && !userOpt.get().getEmail().isEmpty()) {
                                userEmail = userOpt.get().getEmail();
                                System.out.println("User email found from Users table: " + userEmail);
                            } else {
                                System.out.println("No email found in Users table for user id " + job.getUserId() + ", using default.");
                            }

                            System.out.println("Sending email to: " + userEmail + " for job " + job.getId());
                            String subject = "New Vulnerability Detected for Job: " + job.getJobName();
                            String body = "A new vulnerability (" + vuln.getCveId() + ") has been detected for your scheduled job.";
                            try {
                                emailService.sendEmail(userEmail, subject, body);
                            } catch (MessagingException me) {
                                System.err.println("Error sending email for job " + job.getId() + ": " + me.getMessage());
                            }
                        });
                        System.out.println("Job " + job.getId() + ": Fetched " + vulnerabilities.size()
                                + " vulnerabilities, saved " + newVulns.size() + " new ones (with notifications and email).");
                    } else {
                        System.out.println("Job " + job.getId() + ": No vulnerabilities found in the response.");
                    }
                } else {
                    System.out.println("Job " + job.getId() + ": Empty response received from the NVD API.");
                }
            } catch (Exception e) {
                System.err.println("Error fetching vulnerabilities for job " + job.getId() + ": " + e.getMessage());
            }
        }
    }

    /**
     * Constructs the URL for the NVD API call for a specific job,
     * using the details provided by the user.
     * If the job details yield a non-empty keyword (built from vendor, productName, version, and keywords),
     * then only the keywordSearch parameter is included (along with pagination).
     * Otherwise, the publication date range is included.
     * The API key parameter has been removed.
     */
    private String buildNvdApiUrlForJob(ScheduledJob job) {
        String baseUrl = "https://services.nvd.nist.gov/rest/json/cves/2.0";
        StringBuilder keywordBuilder = new StringBuilder();
        if (job.getVendor() != null && !job.getVendor().isEmpty()) {
            keywordBuilder.append(job.getVendor()).append(" ");
        }
        if (job.getProductName() != null && !job.getProductName().isEmpty()) {
            keywordBuilder.append(job.getProductName()).append(" ");
        }
        if (job.getVersion() != null && !job.getVersion().isEmpty()) {
            keywordBuilder.append(job.getVersion()).append(" ");
        }
        if (job.getKeywords() != null && !job.getKeywords().isEmpty()) {
            keywordBuilder.append(job.getKeywords());
        }
        String keywordSearch = keywordBuilder.toString().trim();

        StringBuilder query = new StringBuilder("?resultsPerPage=20&startIndex=0");
        if (!keywordSearch.isEmpty()) {
            query.append("&keywordSearch=").append(URLEncoder.encode(keywordSearch, StandardCharsets.UTF_8));
        } else {
            // If no keyword is provided, include a publication date range
            String pubStartDate = "2000-01-01T00:00:00.000Z";
            String pubEndDate = "2025-03-25T23:59:59.999Z";
            query.append("&pubStartDate=").append(URLEncoder.encode(pubStartDate, StandardCharsets.UTF_8));
            query.append("&pubEndDate=").append(URLEncoder.encode(pubEndDate, StandardCharsets.UTF_8));
        }
        return baseUrl + query.toString();
    }

    /**
     * Wrapper classes for mapping the NVD API JSON response.
     * Adjust these classes to match the exact response structure from the NVD API v2.0.
     */
    public static class VulnerabilityResponse {
        private Result result;

        public Result getResult() {
            return result;
        }

        public void setResult(Result result) {
            this.result = result;
        }
    }

    public static class Result {
        // This example assumes vulnerabilities are returned in a field named "cveItems".
        private List<Vulnerability> cveItems;

        public List<Vulnerability> getCveItems() {
            return cveItems;
        }

        public void setCveItems(List<Vulnerability> cveItems) {
            this.cveItems = cveItems;
        }
    }
}