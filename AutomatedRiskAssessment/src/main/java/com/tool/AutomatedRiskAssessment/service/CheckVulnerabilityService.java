package com.tool.AutomatedRiskAssessment.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.util.UriComponentsBuilder;

import com.tool.AutomatedRiskAssessment.dto.VulnerabilityDataResponse;
import com.tool.AutomatedRiskAssessment.model.*;
import com.tool.AutomatedRiskAssessment.repo.MetricRepository;
import com.tool.AutomatedRiskAssessment.repo.MitigationRepository;
import com.tool.AutomatedRiskAssessment.repo.UserRepository;
import com.tool.AutomatedRiskAssessment.repo.VulnerabilityRepository;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.*;

@Service
public class CheckVulnerabilityService {

	@Autowired
    private MitigationService mitigationService;  // Inject service
	
    @Autowired
    private VulnerabilityRepository vulnerabilityRepository;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private MetricRepository metricRepository;
    
    @Autowired
    private MitigationRepository mitigationRepository;
    

    private final RestTemplate restTemplate = new RestTemplate();

    private static final String NVD_API_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0";
    
    public List<VulnerabilityDataResponse> getVulnerabilities(String company, String product, String version, String keywords) {
        //mitigationService.processVulnerabilities();
    	if(version.equals("*"))
        	version="0";
    	String cpeName = String.format("cpe:2.3:o:%s:%s:%s:*:*:*:*:*:*:*", company, product, version);
        if (keywords == null) keywords = "";
        
        
        String url = NVD_API_URL.concat("?cpeName=").concat(cpeName).concat("&keywordSearch=").concat(keywords);

        Map<String, Object> response = restTemplate.getForObject(url, Map.class);
        
        
        List<VulnerabilityDataResponse> responses= parseCVEResponse(response,company, product, version,keywords);
        
        if (response == null || responses.size()==0) {
        	System.out.println("we not null for o");
        	cpeName = String.format("cpe:2.3:a:%s:%s:%s:*:*:*:*:*:*:*", company, product, version);
            if (keywords == null) keywords = "";
            url = NVD_API_URL.concat("?cpeName=").concat(cpeName).concat("&keywordSearch=").concat(keywords);
            System.out.println("url="+url);
            response = restTemplate.getForObject(url, Map.class);
            responses= parseCVEResponse(response,company, product, version,keywords);
            if (response == null || responses.size()==0)
            {
            	System.out.println("response is null");
            	return Collections.emptyList();
            }
        }
        System.out.println(responses);
        // Return the list of vulnerabilities
        return responses;
    }
    
    public List<VulnerabilityDataResponse> parseCVEResponse(Map<String, Object> response,String company, String product, String version, String keywords){
        List<Map<String, Object>> cveItems = (List<Map<String, Object>>) response.get("vulnerabilities");
        List<VulnerabilityDataResponse> responses = new ArrayList<VulnerabilityDataResponse>();
        for (Map<String, Object> cveItem : cveItems) {
        	VulnerabilityDataResponse dataResponse = new VulnerabilityDataResponse();
        	dataResponse.setSoftwareName(product);
            dataResponse.setVersion(version);
            Map<String, Object> cveData = (Map<String, Object>) cveItem.get("cve");
            String cveId = (String) cveData.get("id");
            dataResponse.setCveId(cveId);
            // Extract other fields like sourceIdentifier, published, etc.
            String sourceIdentifier = (String) cveData.get("sourceIdentifier");
            String published = (String) cveData.get("published");
            String lastModified = (String) cveData.get("lastModified");
            String vulnStatus = (String) cveData.get("vulnStatus");

            // Extract Description (considering language priority, English first)
            String description = "No description available";
            List<Map<String, Object>> descriptions = (List<Map<String, Object>>) cveData.get("descriptions");
            for (Map<String, Object> desc : descriptions) {
                if ("en".equals(desc.get("lang"))) {
                    description = (String) desc.get("value");
                    break;
                }
            }
            dataResponse.setDescription(description);
            dataResponse.setLastModifiedDate(lastModified);
            // Check if Vulnerability already exists
            Vulnerability vulnerability = vulnerabilityRepository.findByCveId(cveId).orElse(null);
            if (vulnerability == null) {
                vulnerability = new Vulnerability(
                    null, // id auto-generated
                    cveId,
                    sourceIdentifier,
                    published,
                    lastModified,
                    vulnStatus,
                    description,
                    new ArrayList<>()   // Empty reference list
                );

                // Handle References
                List<VulnerabilityReference> references = new ArrayList<>();

                List<String> refs=new ArrayList<String>();
                List<Map<String, Object>> referenceData=null;
                if (cveData.containsKey("references")) {
                	referenceData= (List<Map<String, Object>>) cveData.get("references");
                    for (Map<String, Object> ref : referenceData) {
                        String urlRef = (String) ref.get("url");
                        // Create the VulnerabilityReference and set the corresponding URL
                        VulnerabilityReference reference = new VulnerabilityReference();
                        reference.setUrl(urlRef);
                        refs.add(urlRef);
                        reference.setSource((String) ref.get("source"));
                        reference.setVulnerability(vulnerability); // Associate with the vulnerability

                        // Add to references list
                        references.add(reference);
                    }
                }
                dataResponse.setResourceLink(refs);
                vulnerability.setReferences(references);
                // Handle Metrics
                List<Metric> allMetrics = new ArrayList<>();
                if (cveData.containsKey("metrics")) {
                    Map<String, Object> metricsData = (Map<String, Object>) cveData.get("metrics");

                    if (metricsData.containsKey("cvssMetricV2")) {
                        List<Map<String, Object>> cvssMetrics = (List<Map<String, Object>>) metricsData.get("cvssMetricV2");
                        for (Map<String, Object> metric : cvssMetrics) {
                            Map<String, Object> cvssData = (Map<String, Object>) metric.get("cvssData");
                            dataResponse.setSeverity((String)metric.get("baseSeverity"));
                            // Check if metric already exists to avoid duplicates
                            String vectorString = (String) cvssData.get("vectorString");
                                Metric metricEntity = new Metric(
                                    vectorString,
                                    (Double) cvssData.get("baseScore"),
                                    (String) metric.get("baseSeverity"),
                                    vulnerability.getCveId()
                                );
                                // Save metric to the repository
                                metricRepository.save(metricEntity);
                                allMetrics.add(metricEntity);
                        }
                    }
                }

                // Save the vulnerability
                vulnerability = vulnerabilityRepository.save(vulnerability);
                
                //System.out.println("this is not waiting for above line");
            }else {
            	dataResponse.setDescription(description);
            	List<String> refs=new ArrayList<String>();
            	for(VulnerabilityReference ref:vulnerability.getReferences())
            	{
            		refs.add(ref.getUrl());
            	}
            	dataResponse.setSeverity(metricRepository.findSeverityByCveId(cveId));
            	dataResponse.setResourceLink(refs);
            }
            
			responses.add(dataResponse);
        }
        return responses;
    	
    }
}
