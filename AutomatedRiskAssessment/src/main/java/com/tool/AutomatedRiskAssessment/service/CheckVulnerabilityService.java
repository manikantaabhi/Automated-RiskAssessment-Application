package com.tool.AutomatedRiskAssessment.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import com.tool.AutomatedRiskAssessment.dto.VulnerabilityDataResponse;
import com.tool.AutomatedRiskAssessment.model.*;
import com.tool.AutomatedRiskAssessment.repo.MetricRepository;
import com.tool.AutomatedRiskAssessment.repo.MitigationRepository;
import com.tool.AutomatedRiskAssessment.repo.UserRepository;
import com.tool.AutomatedRiskAssessment.repo.VulnerabilityRepository;

import java.util.*;

@Service
public class CheckVulnerabilityService {

	@Autowired
    private MitigationService mitigationService;  // Inject service
	
    @Autowired
    private VulnerabilityRepository vulnerabilityRepository;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private MetricRepository metricRepository;
    
    @Autowired
    private MitigationRepository mitigationRepository;
    

    private final RestTemplate restTemplate = new RestTemplate();

    private static final String NVD_API_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0";

    public List<VulnerabilityDataResponse> getVulnerabilities(String company, String product, String version, String keywords) {
        mitigationService.processVulnerabilities();
    	
    	String cpeName = String.format("cpe:2.3:o:%s:%s:%s:*:*:*:*:*:*:*", company, product, version);
        if (keywords == null) keywords = "";
        
        String url = NVD_API_URL.concat("?cpeName=").concat(cpeName).concat("&keywordSearch=").concat(keywords);

        Map<String, Object> response = restTemplate.getForObject(url, Map.class);
        if (response == null || !response.containsKey("vulnerabilities")) {
            return Collections.emptyList();
        }

        List<Map<String, Object>> cveItems = (List<Map<String, Object>>) response.get("vulnerabilities");
        List<VulnerabilityDataResponse> responses= new ArrayList<>();
        for (Map<String, Object> cveItem : cveItems) {
        	VulnerabilityDataResponse dataResponse = new VulnerabilityDataResponse();
        	dataResponse.setSoftwareName(product);
            dataResponse.setVersion(version);
            Map<String, Object> cveData = (Map<String, Object>) cveItem.get("cve");
            String cveId = (String) cveData.get("id");
            dataResponse.setCveId(cveId);
            // Extract other fields like sourceIdentifier, published, etc.
            String sourceIdentifier = (String) cveData.get("sourceIdentifier");
            String published = (String) cveData.get("published");
            String lastModified = (String) cveData.get("lastModified");
            String vulnStatus = (String) cveData.get("vulnStatus");

            // Extract Description (considering language priority, English first)
            String description = "No description available";
            List<Map<String, Object>> descriptions = (List<Map<String, Object>>) cveData.get("descriptions");
            for (Map<String, Object> desc : descriptions) {
                if ("en".equals(desc.get("lang"))) {
                    description = (String) desc.get("value");
                    break;
                }
            }
            dataResponse.setMitigation(description);
            // Check if Vulnerability already exists
            Vulnerability vulnerability = vulnerabilityRepository.findByCveId(cveId).orElse(null);
            if (vulnerability == null) {
                vulnerability = new Vulnerability(
                    null, // id auto-generated
                    cveId,
                    sourceIdentifier,
                    published,
                    lastModified,
                    vulnStatus,
                    description,
                    new ArrayList<>()   // Empty reference list
                );

                // Handle References
                List<VulnerabilityReference> references = new ArrayList<>();

                List<String> refs=new ArrayList<String>();
                List<Map<String, Object>> referenceData=null;
                if (cveData.containsKey("references")) {
                	referenceData= (List<Map<String, Object>>) cveData.get("references");
                    for (Map<String, Object> ref : referenceData) {
                        String urlRef = (String) ref.get("url");
                        // Create the VulnerabilityReference and set the corresponding URL
                        VulnerabilityReference reference = new VulnerabilityReference();
                        reference.setUrl(urlRef);
                        refs.add(urlRef);
                        reference.setSource((String) ref.get("source"));
                        reference.setVulnerability(vulnerability); // Associate with the vulnerability

                        // Add to references list
                        references.add(reference);
                    }
                }
                dataResponse.setResourceLink(refs);
                vulnerability.setReferences(references);
                // Handle Metrics
                List<Metric> allMetrics = new ArrayList<>();
                if (cveData.containsKey("metrics")) {
                    Map<String, Object> metricsData = (Map<String, Object>) cveData.get("metrics");

                    if (metricsData.containsKey("cvssMetricV2")) {
                        List<Map<String, Object>> cvssMetrics = (List<Map<String, Object>>) metricsData.get("cvssMetricV2");
                        for (Map<String, Object> metric : cvssMetrics) {
                            Map<String, Object> cvssData = (Map<String, Object>) metric.get("cvssData");
                            dataResponse.setSeverity((String)metric.get("baseSeverity"));
                            // Check if metric already exists to avoid duplicates
                            String vectorString = (String) cvssData.get("vectorString");
                                Metric metricEntity = new Metric(
                                    vectorString,
                                    (Double) cvssData.get("baseScore"),
                                    (String) metric.get("baseSeverity"),
                                    vulnerability.getCveId()
                                );
                                // Save metric to the repository
                                metricRepository.save(metricEntity);
                                allMetrics.add(metricEntity);
                        }
                    }
                }

                // Save the vulnerability
                vulnerability = vulnerabilityRepository.save(vulnerability);
                
                //System.out.println("this is not waiting for above line");
            }else {
            	dataResponse.setMitigation(vulnerability.getDescription());
            	List<String> refs=new ArrayList<String>();
            	for(VulnerabilityReference ref:vulnerability.getReferences())
            	{
            		refs.add(ref.getUrl());
            	}
            	dataResponse.setSeverity(metricRepository.findSeverityByCveId(cveId));
            	dataResponse.setResourceLink(refs);
            }
            responses.add(dataResponse);
        }
        
        // Return the list of vulnerabilities
        return responses;
    }
}
