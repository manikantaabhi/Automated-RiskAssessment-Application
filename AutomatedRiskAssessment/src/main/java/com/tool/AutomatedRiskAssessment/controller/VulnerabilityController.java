package com.tool.AutomatedRiskAssessment.controller;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import com.tool.AutomatedRiskAssessment.dto.CheckVulnerabilitiesRequest;
import com.tool.AutomatedRiskAssessment.dto.LoginRequest;
import com.tool.AutomatedRiskAssessment.dto.VulnerabilityDTO;
import com.tool.AutomatedRiskAssessment.dto.VulnerabilityDataResponse;
import com.tool.AutomatedRiskAssessment.dto.VulnerabilityRequestDTO;
import com.tool.AutomatedRiskAssessment.model.User;
import com.tool.AutomatedRiskAssessment.model.VulnerabilityHistory;
import com.tool.AutomatedRiskAssessment.model.VulnerabilityHistoryReference;
import com.tool.AutomatedRiskAssessment.repo.UserRepository;
import com.tool.AutomatedRiskAssessment.repo.VulnerabilityRepository;
import com.tool.AutomatedRiskAssessment.service.CheckVulnerabilityService;
import com.tool.AutomatedRiskAssessment.service.EmailService;
import com.tool.AutomatedRiskAssessment.service.ReportService;
import com.tool.AutomatedRiskAssessment.service.ReportVulnerabilityService;
import com.tool.AutomatedRiskAssessment.service.VulnerabilityService;

@CrossOrigin(origins = "http://localhost:4200")
@RestController
@RequestMapping("/api/vulnerabilities")
public class VulnerabilityController {
	
	@Autowired
	CheckVulnerabilityService checkVulnerabilityService;
	
	@Autowired
	VulnerabilityService vulnerabiltyservice;
	
	@Autowired
	UserRepository userRepository;
	
	@Autowired
    private VulnerabilityRepository vulnerabilityRepository;
	
    @Autowired
    private EmailService emailService;

    @Autowired
    private ReportService reportService;
	


	@PostMapping("/save-vulnerabilities")
	public ResponseEntity<Map<String, String>> saveVulnerabilities(@RequestBody VulnerabilityRequestDTO request) {
	    System.out.println("hitting save");

	    // Get username from request
	    String userId = request.getUsername();
	    System.out.println(userId);

	    // Fetch the User entity
	    User user = userRepository.findByUsername(userId)
	        .orElseThrow(() -> new IllegalArgumentException("User not found"));
	    System.out.println("user=" + user);

	    List<VulnerabilityHistory> vulnerabilities = request.getVulnerabilities();
	    System.out.println(vulnerabilities.size());

	    // Set the user for each VulnerabilityHistory object
	    for (VulnerabilityHistory vulnerabilityHistory : vulnerabilities) {
	        vulnerabilityHistory.setUser(user);

	        // ✅ Set `vulnerabilityHistory` reference in each VulnerabilityHistoryReference
	        for (VulnerabilityHistoryReference reference : vulnerabilityHistory.getReferences()) {
	            reference.setVulnerabilityHistory(vulnerabilityHistory);
	        }
	    }
	    int count=0;
	    List<VulnerabilityHistory> alreadySaved = new ArrayList<>();
	    System.out.println("cul="+vulnerabilities.size());
	    for (VulnerabilityHistory vul : vulnerabilities) {
	        System.out.println("Processing Vulnerability: " + vul.toString());
	        
	        try {
	            // Save all VulnerabilityHistory entities
	            vulnerabilityRepository.save(vul);
	            count++;
	        } catch (Exception e) {
	            // Handle the exception and add it to the alreadySaved list
	            alreadySaved.add(vul);
	            // Log the exception and the record causing it
	            System.err.println("Error saving vulnerability: " + vul.toString());
	            System.err.println("Exception: " + e.getMessage());
	            continue; // Continue processing the next records
	        }
	    }
	    System.out.println("count="+count);
	    if(count>0)
	    	return ResponseEntity.ok().body(Map.of("message", "Data saved successfully."));
	    if(alreadySaved.size()>0)
	        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(Map.of("message", "Cannot Save duplicate records"));

        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(Map.of("message", "Error: Saving failed."));
	}




	@PostMapping(value = "/check", consumes = {"multipart/form-data"})
    public List<VulnerabilityDTO> validateUser(
            @RequestPart(value="make", required=false) String make,
            @RequestPart(value="productName", required=false) String productName,
            @RequestPart(value="version", required=false) String version,
            @RequestPart(value="keywords", required=false) String keywords,
            @RequestPart(value = "file", required = false) MultipartFile file) {
        
		System.out.println("Software Name: " + make);
        System.out.println("Version: " + productName);
        System.out.println("CVE: " + version);
        
       

//        // Create a list of dummy vulnerability data
//        List<VulnerabilityDataResponse> responseList = new ArrayList<>();
//        for (int i = 1; i <= 10; i++) {
//            VulnerabilityDataResponse response = new VulnerabilityDataResponse();
//            response.setSoftwareName(softwareName + " Example " + i);
//            response.setVersion(version);
//            response.setCveId(cve + "-000" + i);
//            response.setSeverity(i % 2 == 0 ? "High" : "Medium");
//            response.setMitigation("Apply patch " + i + " or update software.");
//            response.setResourceLink("https://vulnerability.example.com/cve-" + i);
//            responseList.add(response);
//        }
        List<String[]> parsedData = vulnerabiltyservice.parseCsvFile(file);

        
        for (String[] row : parsedData) {
            System.out.println(String.join(", ", row));  // Display CSV content
        }


        // Return the dummy data as JSON
        return checkVulnerabilityService.getVulnerabilities(make, productName, version, keywords);
    }
	
	@GetMapping("/history/{username}")
    public ResponseEntity<List<VulnerabilityHistory>> getVulnerabilityHistory(@PathVariable String username) {
        // Fetch the vulnerability history for the provided username
		
		System.out.println("fetching history for :"+username);
        List<VulnerabilityHistory> vulnerabilityHistoryList = checkVulnerabilityService.getVulnerabilityHistoryByUsername(username);
        
        if (vulnerabilityHistoryList.isEmpty()) {
            return ResponseEntity.noContent().build();  // Return no content if no records are found
        }
        System.out.println("hisory="+vulnerabilityHistoryList.size());
        return ResponseEntity.ok(vulnerabilityHistoryList);  // Return the list of vulnerability history
    }
	
	@GetMapping("/send-report")
    public ResponseEntity<String> sendReportToEmail(@RequestParam String email) {
        try {
            byte[] excelData = reportService.generateExcel();
            emailService.sendExcelReport(email, excelData);
            return ResponseEntity.ok("Excel report sent successfully to " + email);
        } catch (Exception e) {
            return ResponseEntity.status(500).body("Error sending report: " + e.getMessage());
        }
    }
	
	@Autowired
    private ReportVulnerabilityService reportVulnerabilityService;

    @PostMapping(value = "/report", consumes = {"multipart/form-data"})
    public ResponseEntity<Map<String, Object>> validateUser(
            @RequestPart(value = "make", required = false) String make,
            @RequestPart(value = "productName", required = false) String product,
            @RequestPart(value = "version", required = false) String version,
            @RequestPart(value = "type", required = false) String type,
            @RequestPart("fromDate") String fromDate,
            @RequestPart("toDate") String toDate,
            @RequestPart(value = "file", required = false) MultipartFile file) {

        Map<String, Object> response = reportVulnerabilityService.processWithDateFilter(
            make, product, version, type, fromDate, toDate, file);
        return ResponseEntity.ok(response); // ✅ match type
    }

}
